1.聊项目
2.聊mysql数据类型

->.sql优化方法
->.索引什么情况失效
http://wangking717.iteye.com/blog/2288271
http://www.imooc.com/article/1204

->.ssh和springmvc各自的优劣
1、Struts2是类级别的拦截， 一个类对应一个request上下文，SpringMVC是方法级别的拦截，一个方法对应一个request上下文，而方法同时又跟一个url对应,所以说从架构本身上SpringMVC就容易实现restful url,而struts2的架构实现起来要费劲，因为Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了。
2、由上边原因，SpringMVC的方法之间基本上独立的，独享request response数据，请求数据通过参数获取，处理结果通过ModelMap交回给框架，方法之间不共享变量，而Struts2搞的就比较乱，虽然方法之间也是独立的，但其所有Action变量是共享的，这不会影响程序运行，却给我们编码 读程序时带来麻烦，每次来了请求就创建一个Action，一个Action对象对应一个request上下文。
3、由于Struts2需要针对每个request进行封装，把request，session等servlet生命周期的变量封装成一个一个Map，供给每个Action使用，并保证线程安全，所以在原则上，是比较耗费内存的。
4、 拦截器实现机制上，Struts2有以自己的interceptor机制，SpringMVC用的是独立的AOP方式，这样导致Struts2的配置文件量还是比SpringMVC大。
5、SpringMVC的入口是servlet，而Struts2是filter（这里要指出，filter和servlet是不同的。以前认为filter是servlet的一种特殊），这就导致了二者的机制不同，这里就牵涉到servlet和filter的区别了。
6、SpringMVC集成了Ajax，使用非常方便，只需一个注解@ResponseBody就可以实现，然后直接返回响应文本即可，而Struts2拦截器集成了Ajax，在Action中处理时一般必须安装插件或者自己写代码集成进去，使用起来也相对不方便。
7、SpringMVC验证支持JSR303，处理起来相对更加灵活方便，而Struts2验证比较繁琐，感觉太烦乱。
8、spring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高（当然Struts2也可以通过不同的目录结构和相关配置做到SpringMVC一样的效果，但是需要xml配置的地方不少）。
9、 设计思想上，Struts2更加符合OOP的编程思想， SpringMVC就比较谨慎，在servlet上扩展。
10、SpringMVC开发效率和性能高于Struts2。
11、SpringMVC可以认为已经100%零配置。

->.线程池的知识，锁概念(自旋锁，悲观锁，乐观锁定义)
自旋锁是一种非阻塞锁，也就是说，如果某线程需要获取自旋锁，但该锁已经被其他线程占用时，该线程不会被挂起，而是在不断的消耗CPU的时间，不停的试图获取自旋锁。

互斥量是阻塞锁，当某线程无法获取互斥量时，该线程会被直接挂起，该线程不再消耗CPU时间，当其他线程释放互斥量后，操作系统会激活那个被挂起的线程，让其投入运行。

两种锁适用于不同场景：

如果是多核处理器，如果预计线程等待锁的时间很短，短到比线程两次上下文切换时间要少的情况下，使用自旋锁是划算的。

如果是多核处理器，如果预计线程等待锁的时间较长，至少比两次线程上下文切换的时间要长，建议使用互斥量。

如果是单核处理器，一般建议不要使用自旋锁。因为，在同一时间只有一个线程是处在运行状态，那如果运行线程发现无法获取锁，只能等待解锁，但因为自身不挂起，所以那个获取到锁的线程没有办法进入运行状态，只能等到运行线程把操作系统分给它的时间片用完，才能有机会被调度。这种情况下使用自旋锁的代价很高。

如果加锁的代码经常被调用，但竞争情况很少发生时，应该优先考虑使用自旋锁，自旋锁的开销比较小，互斥量的开销较大。

->.spring的aop怎么实现的
https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/

->.hashcode和equals方法有什么联系
集合方向去答
http://www.cnblogs.com/Qian123/p/5703507.html
这样一来，当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。所以这里存在一个冲突解决的问题。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。  

->.索引的b树存储与hash存储
http://www.cnblogs.com/heiming/p/5865101.html


5.oracle存储过程的优缺点
7.java集合知识(arraylist和linkedlist时间复杂度比较)
11.二分法排序(折半排序)实现
12.各种问题延伸的为什么
14.数据结构
15.hashmap，索引存储结构，并发
16.tcp  ip  udp
17.netty的线程模型是reactor模型  分为单线程多线程主从线程
18.netty建立连接和发消息的过程
19.select/poll和epoll的区别
20.JVM是怎么回收垃圾有什么方式
21.fastdfs基本架构和文件上传机制
22.rabbitmq  rpc底层的机制
23.fastdfs的分布式如何做
24.容灾怎么处理
25.分布式的session的共享机制如何做
26.分布式锁  数据库扩容
27.谈谈你最熟悉的一套系统的架构
28.用到哪些框架，用到DUBBO,REDIS,MQ等
29.然后他就说和他们公司的框架一致，然后就逐个聊DUBBO,REDIS,MQ里面踩过的坑，有哪些问题要注意等等。
30.分布式事务，和分布式锁的解决。
31.设计模式
32. 有一个通讯录有几百万条数，用mysql数据库来处理，在查找一个信息的时候用什么方案可以高效快速找到并且把相似度最高的前十排列出来
33.分布式事务怎么控制
34.集群日志高效处理
35.dubbo运用过程中出现什么问题
36.负载均衡的项目中，如果有服务器出现问题，怎么快速的找到具体是哪台服务器出现问题
37.Tcp协议 如何保证可靠传输 
下载为什么会慢慢变快
38.Netty线程模型，boss线程组和walker线程组如何交互 
Netty workers线程组为什么设计成不竞争模式
移动端网络很差 
39.如何在应用层稍微的避免丢包重传
Http 和tcp协议不同和比较
40.设计一个分布式调度系统，支持任务切片 主要是服务器和客户端需要暴露什么接口
41.讲一下zookeeper如何选master 主要是paxos协议过程
42.Nginx为什性能那么高，nginx框架结构谅解
43.分布式锁的实现，比如redis,zookeeper,数据库
44.Select poll epoll 区别 为什么epoll性能高，在等网络数据到达，数据从内核区拷贝到用户区这两个过程中用户线程的阻塞状态
46.Mysql 有哪些索引，都是如何实现的
47.Innodb为什么使用聚簇索引，数据是怎么存储的，为什么要这样设计，有什么好处，为什么用B+树
48.设计一个监控告警系统
49.springMVC（restful接口），spring的事务管理（防止脏数据），aop思想，mysql的sql优化（索引的理解、具体建索引的场景，啥时候用where和having），多线程的应用和理解，分布式锁和分布式事务管理，linux基本命令，dubbo的应用，redis的应用
50.设计模式
51.谈谈你最熟悉的一套系统的架构
52.用到哪些框架，用到DUBBO,REDIS,MQ等
53.然后他就说和他们公司的框架一致，然后就逐个聊DUBBO,REDIS,MQ里面踩过的坑，有哪些问题要注意等等。
54.面试针对简历上核心技能问基本原理，实现思路，底层原理，如何在场景下面扩展
新补充：
mysql搜索引擎区别，底层实现
设计模式
项目中重构过哪些代码，有哪些优化
tomcat调优
mybatis原理
nginx底层实现
dubbo源码
springmvc源码
分布式锁和分布式事务的实现
数据库优化
虚拟机内存分析
hashmap的原理以及扩容
消息中间件消息怎么去重
高并发的处理措施
Arraylist和linkedlist的区别
mysql有哪些索引，B+树怎么达到平衡的，增加一个节点是什么流程
mysql隔离级别有哪些，他是怎么实现这些隔离的
dubbo框架是如何实现寻址到调用目标方法
jvm如何实现cms